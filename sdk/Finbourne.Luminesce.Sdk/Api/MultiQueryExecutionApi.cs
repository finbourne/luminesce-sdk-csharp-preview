/*
 * FINBOURNE Luminesce Web API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.13.446
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Finbourne.Luminesce.Sdk.Client;
using Finbourne.Luminesce.Sdk.Model;

namespace Finbourne.Luminesce.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiQueryExecutionApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set
        /// </summary>
        /// <remarks>
        /// Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>BackgroundQueryCancelResponse</returns>
        BackgroundQueryCancelResponse CancelMultiQuery(string executionId);

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set
        /// </summary>
        /// <remarks>
        /// Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>ApiResponse of BackgroundQueryCancelResponse</returns>
        ApiResponse<BackgroundQueryCancelResponse> CancelMultiQueryWithHttpInfo(string executionId);
        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set
        /// </summary>
        /// <remarks>
        /// View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>BackgroundMultiQueryProgressResponse</returns>
        BackgroundMultiQueryProgressResponse GetProgressOfMultiQuery(string executionId);

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set
        /// </summary>
        /// <remarks>
        /// View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>ApiResponse of BackgroundMultiQueryProgressResponse</returns>
        ApiResponse<BackgroundMultiQueryProgressResponse> GetProgressOfMultiQueryWithHttpInfo(string executionId);
        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.
        /// </summary>
        /// <remarks>
        ///  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <returns>BackgroundMultiQueryResponse</returns>
        BackgroundMultiQueryResponse StartQueries(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?));

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.
        /// </summary>
        /// <remarks>
        ///  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <returns>ApiResponse of BackgroundMultiQueryResponse</returns>
        ApiResponse<BackgroundMultiQueryResponse> StartQueriesWithHttpInfo(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiQueryExecutionApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set
        /// </summary>
        /// <remarks>
        /// Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundQueryCancelResponse</returns>
        System.Threading.Tasks.Task<BackgroundQueryCancelResponse> CancelMultiQueryAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set
        /// </summary>
        /// <remarks>
        /// Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundQueryCancelResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BackgroundQueryCancelResponse>> CancelMultiQueryWithHttpInfoAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set
        /// </summary>
        /// <remarks>
        /// View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundMultiQueryProgressResponse</returns>
        System.Threading.Tasks.Task<BackgroundMultiQueryProgressResponse> GetProgressOfMultiQueryAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set
        /// </summary>
        /// <remarks>
        /// View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundMultiQueryProgressResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BackgroundMultiQueryProgressResponse>> GetProgressOfMultiQueryWithHttpInfoAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.
        /// </summary>
        /// <remarks>
        ///  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundMultiQueryResponse</returns>
        System.Threading.Tasks.Task<BackgroundMultiQueryResponse> StartQueriesAsync(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.
        /// </summary>
        /// <remarks>
        ///  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </remarks>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundMultiQueryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BackgroundMultiQueryResponse>> StartQueriesWithHttpInfoAsync(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiQueryExecutionApi : IMultiQueryExecutionApiSync, IMultiQueryExecutionApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MultiQueryExecutionApi : IMultiQueryExecutionApi
    {
        private Finbourne.Luminesce.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiQueryExecutionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MultiQueryExecutionApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiQueryExecutionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MultiQueryExecutionApi(String basePath)
        {
            this.Configuration = Finbourne.Luminesce.Sdk.Client.Configuration.MergeConfigurations(
                Finbourne.Luminesce.Sdk.Client.GlobalConfiguration.Instance,
                new Finbourne.Luminesce.Sdk.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Finbourne.Luminesce.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Finbourne.Luminesce.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Finbourne.Luminesce.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiQueryExecutionApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MultiQueryExecutionApi(Finbourne.Luminesce.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Finbourne.Luminesce.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Finbourne.Luminesce.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Finbourne.Luminesce.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiQueryExecutionApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public MultiQueryExecutionApi(Finbourne.Luminesce.Sdk.Client.ISynchronousClient client, Finbourne.Luminesce.Sdk.Client.IAsynchronousClient asyncClient, Finbourne.Luminesce.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Finbourne.Luminesce.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Finbourne.Luminesce.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Finbourne.Luminesce.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Finbourne.Luminesce.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Finbourne.Luminesce.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>BackgroundQueryCancelResponse</returns>
        public BackgroundQueryCancelResponse CancelMultiQuery(string executionId)
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundQueryCancelResponse> localVarResponse = CancelMultiQueryWithHttpInfo(executionId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>ApiResponse of BackgroundQueryCancelResponse</returns>
        public Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundQueryCancelResponse> CancelMultiQueryWithHttpInfo(string executionId)
        {
            // verify the required parameter 'executionId' is set
            if (executionId == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'executionId' when calling MultiQueryExecutionApi->CancelMultiQuery");

            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("executionId", Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToString(executionId)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request
            var localVarResponse = this.Client.Delete<BackgroundQueryCancelResponse>("/api/MultiQueryBackground/{executionId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelMultiQuery", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundQueryCancelResponse</returns>
        public async System.Threading.Tasks.Task<BackgroundQueryCancelResponse> CancelMultiQueryAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundQueryCancelResponse> localVarResponse = await CancelMultiQueryWithHttpInfoAsync(executionId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set Cancel the query-set (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundQueryCancelResponse)</returns>
        public async System.Threading.Tasks.Task<Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundQueryCancelResponse>> CancelMultiQueryWithHttpInfoAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'executionId' is set
            if (executionId == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'executionId' when calling MultiQueryExecutionApi->CancelMultiQuery");


            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };


            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("executionId", Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToString(executionId)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<BackgroundQueryCancelResponse>("/api/MultiQueryBackground/{executionId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelMultiQuery", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>BackgroundMultiQueryProgressResponse</returns>
        public BackgroundMultiQueryProgressResponse GetProgressOfMultiQuery(string executionId)
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryProgressResponse> localVarResponse = GetProgressOfMultiQueryWithHttpInfo(executionId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <returns>ApiResponse of BackgroundMultiQueryProgressResponse</returns>
        public Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryProgressResponse> GetProgressOfMultiQueryWithHttpInfo(string executionId)
        {
            // verify the required parameter 'executionId' is set
            if (executionId == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'executionId' when calling MultiQueryExecutionApi->GetProgressOfMultiQuery");

            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("executionId", Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToString(executionId)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request
            var localVarResponse = this.Client.Get<BackgroundMultiQueryProgressResponse>("/api/MultiQueryBackground/{executionId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressOfMultiQuery", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundMultiQueryProgressResponse</returns>
        public async System.Threading.Tasks.Task<BackgroundMultiQueryProgressResponse> GetProgressOfMultiQueryAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryProgressResponse> localVarResponse = await GetProgressOfMultiQueryWithHttpInfoAsync(executionId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set View progress information (up until this point) for the entire query-set The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon   1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.   1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.   1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionId">ExecutionId returned when starting the query</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundMultiQueryProgressResponse)</returns>
        public async System.Threading.Tasks.Task<Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryProgressResponse>> GetProgressOfMultiQueryWithHttpInfoAsync(string executionId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'executionId' is set
            if (executionId == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'executionId' when calling MultiQueryExecutionApi->GetProgressOfMultiQuery");


            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };


            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("executionId", Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToString(executionId)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<BackgroundMultiQueryProgressResponse>("/api/MultiQueryBackground/{executionId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProgressOfMultiQuery", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <returns>BackgroundMultiQueryResponse</returns>
        public BackgroundMultiQueryResponse StartQueries(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?))
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryResponse> localVarResponse = StartQueriesWithHttpInfo(type, body, asAt, effectiveAt, limit1, limit2, input1, input2, input3, timeoutSeconds, keepForSeconds);
            return localVarResponse.Data;
        }

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <returns>ApiResponse of BackgroundMultiQueryResponse</returns>
        public Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryResponse> StartQueriesWithHttpInfo(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'body' when calling MultiQueryExecutionApi->StartQueries");

            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "text/plain"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "type", type));
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (limit1 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit1", limit1));
            }
            if (limit2 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit2", limit2));
            }
            if (input1 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input1", input1));
            }
            if (input2 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input2", input2));
            }
            if (input3 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input3", input3));
            }
            if (timeoutSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "timeoutSeconds", timeoutSeconds));
            }
            if (keepForSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "keepForSeconds", keepForSeconds));
            }
            localVarRequestOptions.Data = body;

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request
            var localVarResponse = this.Client.Put<BackgroundMultiQueryResponse>("/api/MultiQueryBackground", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartQueries", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BackgroundMultiQueryResponse</returns>
        public async System.Threading.Tasks.Task<BackgroundMultiQueryResponse> StartQueriesAsync(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryResponse> localVarResponse = await StartQueriesWithHttpInfoAsync(type, body, asAt, effectiveAt, limit1, limit2, input1, input2, input3, timeoutSeconds, keepForSeconds, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// StartQueries: Starts to Execute the LuminesceSql statements in the background.  Allow for starting a potentially long running query and getting back an immediate response with how to  - fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis - view progress information (up until this point), for all results in one go - cancel the queries (if still running) / clear the data (if already returned)  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time) - 401 Unauthorized 
        /// </summary>
        /// <exception cref="Finbourne.Luminesce.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">An enum value defining the set of statements being executed</param>
        /// <param name="body">A \&quot;search\&quot; value (e.g. &#39;Apple&#39; on an instrument search, a &#x60;Finbourne.Filtering&#x60; expression of Insights, etc.)  In the cases where \&quot;Nothing\&quot; is valid for a &#x60;Finbourne.Filtering&#x60; expression, pass &#x60;True&#x60;.</param>
        /// <param name="asAt">The AsAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="effectiveAt">The EffectiveAt time used by any bitemporal provider in the queries. (optional)</param>
        /// <param name="limit1">A limit that is applied to first-level queries (e.g. Instruments themselves) (optional)</param>
        /// <param name="limit2">A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found) (optional)</param>
        /// <param name="input1">A value available to queries, these vary by &#39;type&#39; and are only used by some types at all.  e.g. a start-date of some sort (optional)</param>
        /// <param name="input2">A second value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="input3">A third value available to queries, these vary by &#39;type&#39; and are only used by some types at all. (optional)</param>
        /// <param name="timeoutSeconds">Maximum time the query may run for, in seconds: &lt;0 → ∞, 0 → 1200s (20m) (optional, default to 0)</param>
        /// <param name="keepForSeconds">Maximum time the result may be kept for, in seconds: &lt;0 → 1200 (20m), 0 → 28800 (8h), max &#x3D; 2,678,400 (31d) (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BackgroundMultiQueryResponse)</returns>
        public async System.Threading.Tasks.Task<Finbourne.Luminesce.Sdk.Client.ApiResponse<BackgroundMultiQueryResponse>> StartQueriesWithHttpInfoAsync(MultiQueryDefinitionType type, string body, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOffset? effectiveAt = default(DateTimeOffset?), int? limit1 = default(int?), int? limit2 = default(int?), string input1 = default(string), string input2 = default(string), string input3 = default(string), int? timeoutSeconds = default(int?), int? keepForSeconds = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new Finbourne.Luminesce.Sdk.Client.ApiException(400, "Missing required parameter 'body' when calling MultiQueryExecutionApi->StartQueries");


            Finbourne.Luminesce.Sdk.Client.RequestOptions localVarRequestOptions = new Finbourne.Luminesce.Sdk.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "text/plain"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };


            var localVarContentType = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Finbourne.Luminesce.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "type", type));
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (limit1 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit1", limit1));
            }
            if (limit2 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit2", limit2));
            }
            if (input1 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input1", input1));
            }
            if (input2 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input2", input2));
            }
            if (input3 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "input3", input3));
            }
            if (timeoutSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "timeoutSeconds", timeoutSeconds));
            }
            if (keepForSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Finbourne.Luminesce.Sdk.Client.ClientUtils.ParameterToMultiMap("", "keepForSeconds", keepForSeconds));
            }
            localVarRequestOptions.Data = body;

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            //  set the LUSID header
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Language", "C#");
            localVarRequestOptions.HeaderParameters.Add("X-LUSID-Sdk-Version", "1.13.446");

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<BackgroundMultiQueryResponse>("/api/MultiQueryBackground", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartQueries", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}